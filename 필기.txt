웹사이트 ----- 웹어플리케이션
non-interactive ---- interactive
interactive하다면 웹앱을 골라야하고, 바닐라 js보다는 react같은게 적절함.
js는 브라우저에 내장되어있음.

nodeJS?
자바스크립트를 브라우저 밖으로 가져와서 활용할 수 있도록 함.

require?
node module을 어딘가에서 가져오는거임.
처음엔 내 작업폴더 속, 그다음엔 node_modules 폴더
그 안에도 require있고.. 계속..

* 깃허브 사용
 - (프로젝트 폴더에서) git init
 - 깃허브에서 repository 생성
 - node_module을 ignore
   - .gitignore 파일 생성
   - node_modules 작성
   - gitignore nodejs 검색해서 나온 코드 복사붙여넣기
   - package-lock.json도 추가 (패키지 보안 관련)
 - README.md 파일 생성
 - git remote add origin (github 저장소 주소)
 - git add .
 - git commit -m "Initial Commit"
 - git push origin master

* 서버 만들기
 - express 코드
   - const express = require('express') : node module을 가져오기(import)
     - 내 폴더에서 찾고, 없으면 node_modules에서 찾음
   - const app = express() : application 생성
   - app.listen(4000) : 4000번 포트 리슨 명령
   - 터미널에서 node index.js
   - 브라우저에서 localhost:4000
   - app.listen(4000)을 콜백으로 만들기
     - app.listen(4000, handleListening)
   - const PORT = 4000;
 - package.json을 중앙컨트롤타워로 만들기
   - package.json에 "scripts":{"start":"node index.js"} 추가 -> npm start 명령으로 서버 실행 가능


   문자열 안에 변수넣을때 `(~키)로 묶고 ${변수명} 하면 댐

   [GET, POST]
기본적으로 브라우저가 페이지를 읽어올 때 GET방식으로..
로그인같은 정보가 담겨있을 땐 POST방식으로 

예를 들어 영상에 코멘트를 달 때에는 POST로  


RESPONSE는 요청을 받으면 응답을 해야한다. 


================================
function handleHome(req, res){
    res.send('Hello from home');
}

app.get("/", handleHome);
====================================
function handleProfile(req, res){
    res.send("You are on my profile")
}

app.get("/profile", handleProfile);
============================

보통 웹사이트에 데이터를 주고받을 때 request / respose object가 작동하는데, 
누가 페이지를 요청했는지나 어떤 데이터가 페이지로 전송됐는지 등에 대해
우리가 정보를 얻고자 하면 request를 이용할 것임.
만약 누군가 post로 아이디, 비번을 보낸다면 서버에서는 request로 받을 수 있음.

웹사이트처럼 페이지이동을 하고싶게 하려면 res.send("text") 가 아닌 
완전한 html, css 파일을 send해줘야한다.  
이것이 이번 코스에서 배우게 될 것. 이것이 기본적인 동작 방법

서버를 생성하고 route를 생성하고 그에 대해 응답한다. 

express 와 node.js로 간단하게 할 수 있다.

* Babel
 : 최신의 JS코드(ES6)를 예전의(표준) JS코드로 변환해줌 = nodeJS에서 최신의 코드를 사용할 수 있게 함
 - 사용 방법
   1) Babel node
     - npm install @babel/node
 - 다양한 Stage(버전?) 존재
   - 우리는 env 사용 : 최신이면서 안정적
   - npm install @babel/preset-env
   - npm install @babel/core 
 - .babelrc 파일 생성
   - { "presets": ["@babel/preset-env"]
 - 새 문법
   - require -> import ~ from
   - node index.js -> babel-npde index.js
   - function ~ -> const ~ = ( , ) => ~;    // arrow function

   babelrc에는 ndoejs, js, react등의 필요한 설정을 집어넣을것임. 

* nodemon
 : 파일 저장할 때마다 서버를 재실행
 - npm install nodemon -D // 프로젝트 dependency와 상관없이 설치
 - babel-node index.js -> nodemon --exec babel-node index.js


* 서버 재시작 딜레이 시간 주기
 - node --exec babel-node index.js --delay 2

* express
 - middleware
   - 처리가 끝날 때까지 연결되어 있는
   - 유저의 요청과 서버의 응답 사이에 있는 것
   - express에서의 모든 함수는 middleware가 될 수 있음
     get 함수의 인자를 3개 주고 2번째에 middleware 함수를 넣으면 됨
     마지막 함수는 res.send 해야 웹사이트가 로딩중이지 않음
   - 모든 요청에 미들웨어 설정 방법 : app.use(); // get함수(route 처리) 이전에 먼저 설정

만약 미들웨어에서 route 전에 먼저 next 대신 res.send 를 보내면 연결을 끊을 수 있음. 

* express router
 - route들의 복잡함을 쪼개어 단순화
 - router = 많은 route들이 담긴 파일
 - router.js 생성
   - import express from "express"
   - export const userRouter = express.Router(); // 파일로(X) 변수로(O) export

app.use("/user", userRouter);
   app.get 이 아닌 use는 누군가 /user 경로에 접속하면 userRouter에 있는 route 전체를 사용할 수 있게 하겠다는 것
   

*MVC 패턴
 - Model(데이터, DB), View(데이터의 생김새, template) Controller(데이터를 찾는 함수)의 약자
 - 패턴 : 구조
 - 방법
   1. 데이터 모습에 맞게 URL(router)과 함수(Controller) 분리
     - app.js의 get 호출, handler 삭제
     - router.js -> userRouter.js 이름 변경
     - videoRouter.js 생성
     - routers 폴더 생성, router들 넣기
     - userRouter.js : get 호출 삭제
     - userRouter.js, videoRouter.js : 파일로 export(export default ~)
     - app.js
       - import userRouter & videoRouter
       - app.use("/user", userRouter); app.use("/video", videoRouter);
     - globalRouter.js 생성
       - export default globalRouter 하도록 코드 작성
       - app.js
         - app.use("/", globalRouter) 하도록 import하고 코드 작성


단어 클릭하고 ctrl D 하면 해당단어 한버넹 바꿀 수 있다.

export default? 파일로 export하는거
export const ~ 는 그 변수만 export한다는거


* URL 만들기
 - 프로젝트 폴더에 routes.js 생성(어디서든 모든 URL을 불러 쓸 수 있게)
   - URL 관련 상수 선언(6분21초)
     - URL 문자열 안에 콜론 쓰면 express가 변수 처리함
   - route 객체 생성(7분12초)
 - app.js : import routes from "./routes.js";
   - app.use("/", ~) 에서 / &/user & /video 대신 routes.home &  routes.users & route.video로 변경
 - globalRouter.js
   - import routes from "../routes";
   - globalRouter.get(routes.home, (req, res) => res.send('Home'));
   - join, login, logout, search도 작성(9분29초)


const USERS_DETAIL = "/:id"; ->express에서 : 뒤에오는 값은 변화하는 값이라고 인식함.

../routes ? 이 디렉토리 밖으로 나간다

..const routes에서 선언한 변수명과 다른 router에서 쓰인 property명이 다르면 
C:\Users\syc\Documents\WeTube\node_modules\path-to-regexp\index.js:63
  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
                                                ^

TypeError: Cannot read property 'length' of undefined

이런 에러남.....ㅅㅂ...

export한 변수가 있으면 다른 파일에서도 그 변수명 쳤을때 네모 안 두줄 있는거 누르면 auto import가 됨.

export const join = (req, res) => res.send("Join");
arrow function에는 implicit return 이라는게 있는데, 

function lala () {
  return true
}

이걸

const lala = () => true;

이렇게 쓸 수 있음. 리턴 표시 없이.
근데 만약 중괄호를 쓴다면 표기해줘야함.

const lala = () => {
  return true;
}
이렇게


pug?
express에서 view를 다루는 방식중의 하나인데, res.send 대신 html을 전달할 수 있게 해줌

- app.set()(application 설정 함수)를 사용하여 view engine을 undefined에서 pug로 변경
   - pug & express의 view 파일들 위치 경로를 바꾸려면 set 함수의 name으로 'views' 주면 됨
   - default는 views 폴더이므로 우리는 views 폴더 생성
     - home.pug 생성
 - 문법
   - p : html p태그 생성
 - controller에서 send 대신 render( 문자열)

 * Pug : HTML CSS를 논리적으로 작업 가능 & <>대신 들여쓰기 사용
 - views 폴더에 layouts 폴더 생성
   - layout 파일 생성
     - main.pug : 공통으로 적용될 html, head, header, footer, css link 등의 코드
       - block : 다른 레이아웃이 들어갈 자리
         - 레이아웃 사용 방법 : block에 들어갈 레이아웃 파일 제일 위에 extension(기본 템플릿을 이 파일에 끌어와서 확장해서 사용하겠다)
           - extends layouts/main.pug
           - block content에 들여쓰기 해서 내용 작성

* partials : 페이지의 일부분
 - views 폴더에 partials 폴더 생성
   - footer.pug, header.pug 생성
     - fontawesome 설치 : main.pug head에 코드 복사(git commit 참고)
   - footer.pug 작성 후 main.pug의 footer 자리에 include ../partials/footer

* pug에 자바스크립트 코드 작성하기 : #{ } 안에 쓰기
#{} is the pug way
${} is the ES6 way

Block is when we want to be able to put something inside of a space previously created.
Include just adds some HTML.
Block is used as a way of adding dynamic content to a template, like on this example the layout.pug has some defined HTML and a block called content.
In this case when I use the block 'content' I'm putting it inside of the previously defined block by my layout.

* 템플릿에 컨트롤러 정보 추가
 - 템플릿 전체에 추가하기
   - ex) 헤더라 라우트 객체에 접근
     - locals 미들웨어 만들어 사용 : local 변수를 global 변수로 사용하게 함
       - res.locals.변수명 = 정보
       - pug 파일에서 #{변수명}으로 사용 가능


app.use((req, res, next) => {
    
})

===

app.use(function(req, res, next){

})

===

const localMiddleware = (req, res, next) => {

}

p= , p#{} 차이
p=potato is the same as p #{potato}
If you only want to put one variable inside of an element all you do is =
But if you want to add something more than one variable combined with text
p Hello this is #{potato}

* mixin: 웹사이트에서 자주 반복되는 html 코드를 재활용하는 방법
 - pug 함수의 일종
   - 인자 1개 필요
..다른정보, 같은 구조!

videoBlcok 파일에어 어떻게 아래처럼 videoFile에 접근 가능한가?
video.videoBlock__thumbnail(src=video.videoFile)
videoBlock은 home에서 사용되고있다. home에서 .videos 를 가져오고 있고, 이건 middlewares.js에서 res.locals.routes = routes; 를 써서
local 변수를 global 변수로 사용하게 했다! routes에는 videos가 있음. 근데 이건 어떻게 db랑 연결이 되지? 비디오라우터에서 video변수를 빼고,
대신 db에서 videos를 export해서 그걸 가져다 쓸 수 있는거네

get route의 argument?
get(url, controller)

MongoDB?
NoSQL인 Database(C++), mongoose를 통해 database와 javascript를 연결할 수 있음.
NoSQL이어서 규칙이 적고 유연, 수정 가능성이 많음.
relationship이 없다면 mongoDB는 좋은 선택! 예를 들어 채팅앱같은.
트랜잭션이 필요한 경우에는 부적합하다. (ex. 금융, 결제, 회원정보 등)

dotenv? 

dotenv가 nodejs서버의 환경변수

.env파일에서는 변수명 뒤에 세미콜론을 입력하면 안됨.

model?
mongDB한테 우리의 파일은 video라는 이름을 가질거고, 모든 비디오들은 string type을 가질거고,
video는 view를 가질거고 ..등등을 알려줌.

